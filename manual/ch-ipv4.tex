% based on 'integration' branch: a4af10cd976d27c3af546230f4e27e3688cf29ad

\chapter{IPv4}
\label{cha:ipv4}


\section{Overview}

routing: hosts, routers

fragmentation

options

\subsection{Implemented standards}

\begin{itemize}
  \item RFC791: Internet Protocol
  \item RFC792: Internet Control Message Protocol
  \item RFC826: Address Resolution Protocol
  \item RFC903: A Reverse Address Resolution Protocol
  \item RFC1122: Requirements for Internet Hosts - Communication Layers
%  \item RFC1868: ARP Extension -- UNARP
\end{itemize}


\subsection{INET modules}

TODO list the modules: IP, ICMP, RoutingTable, etc.



\section{The IPv4 Module}

The \nedtype{IPv4} module implements the IPv4 protocol.

For connecting the upper layer protocols the \nedtype{IPv4} module
has \emph{transportIn[]} and \emph{transportOut[]} gate vectors.

The IP packets are sent to the \nedtype{ARP} module through the
\emph{queueOut} gate. The incoming IP packets are received
directly from the network interface cards through the
\emph{queueIn[]} gates. Each interface card knows its own
network layer gate index.

% \subsection{Performance model, QoS}
% 
% In the current form, IP contains a FIFO which queues up IP datagrams;
% datagrams are processed in order. The processing time is determined by the
% \ttt{procDelay} module parameter.
% 
% The current performance model comes from the \cppclass{QueueBase} C++ base
% class. If you need a more sophisticated performance model, you may change
% the module implementation (the IP class), and: (1) override the
% startService() method which determines processing time for a packet, or (2)
% use a different base class.

\subsection{IP packets}

IP packets, IP header

\begin{center}
\begin{bytefield}{32}
\bitheader{0,3,4,7,8,15,16,18,19,23,24,31} \\
\bitbox{4}{Version} &
\bitbox{4}{IHL} &
\bitbox{8}{\small Type of Service} &
\bitbox{16}{Total Length} \\
\bitbox{16}{Identification} &
\bitbox{3}{Flags} &
\bitbox{13}{Fragment Offset} \\
\bitbox{8}{Time to Live} &
\bitbox{8}{Protocol} &
\bitbox{16}{Header Checksum} \\
\bitbox{32}{Source Address} \\
\bitbox{32}{Destination Address} \\
\bitbox{24}{Options} &
\bitbox{8}{Padding} \\
\end{bytefield}
\end{center}

The \ttt{Version} field is 4 for IPv4. The 4-bit \ttt{IHL} field is the
number of 32-bit words in the header. It is needed because the header
may contain optional fields, so its length may vary. The minimum IP header
length is 20, the maximum length is 60. The header is always padded to
multiple of 4 bytes. The \ttt{Type of Service} field designed to store
priority and preference values of the IP packet, so applications can
request low delay, high throughput, and maximium reliability from the
routing algorithms. In reality these fields are rarely set by applications,
and the routers mostly ignore them. The \ttt{Total Length} field is the
length of the whole datagram in bytes. The \ttt{Identification} field
is used for identifying the datagram sent by a host. It is usually generated
by incrementing a counter for each outgoing datagram. When the datagram
gets fragmented by a router, its \ttt{Identification} field is kept unchanged
to the other end can collect them. In datagram fragments the \ttt{Fragment Offset}
is the address of the fragment in the payload of the original datagram. It is
measured in 8-byte units, so fragment lengths must be a multiple of 8.
Each fragment except the last one, has its \ttt{MF} (more fragments) bit set
in the \ttt{Flags} field. The other used flag in \ttt{Flags} is the \ttt{DF}
(don't fragment) bit which forbids the fragmentation of the datagram.
The \ttt{Time to Live} field is decremented by each router in the path,
and the datagram is dropped if it reached 0. Its purpose is to prevent
endless cycles if the routing tables are not properly configured, but
can be used for limiting hop count range of the datagram (e.g. for local
broadcasts, but the \fprog{traceroute} program uses this field too).
The \ttt{Protocol} field is for demultiplexing the payload of the IP
datagram to higher level protocols. Each transport protocol has a registered
protocol identifier. The \ttt{Header Checksum} field is the 16-bit one's
complement sum of the header fields considered as a sequence of 16-bit numbers.
The \ttt{Source Address} and \ttt{Destination Address} are the IPv4 addresses
of the source and destination respectively.

The \ttt{Options} field contains 0 or more IP options. It is always padded
with zeros to a 32-bit boundary. An option is either a single-byte option
code or an option code + option length followed by the actual values for
the option. Thus IP implementations can skip unknown options.

An IP datagram is represented by the \msgtype{IPv4Datagram} message class.
It contains variables corresponding the fields of the IP header, except:
\begin{itemize}
  \item \fvar{Header Checksum} omitted, modeled by error bit of packets
  \item \fvar{Options} only the following options are permitted and the
                       datagram can contain at most one option:
        \begin{itemize}
          \item Loose Source Routing
          \item Strict Source Routing
          \item Timestamp
          \item Record Route
        \end{itemize}
\end{itemize}

The \fvar{Type of Service} field is called \ttt{diffServCodePoint} in
\nedtype{IPv4Datagram}.

Before sending the \msgtype{IPv4Datagram} through the network, the \nedtype{IPv4}
module attaches a \cppclass{IPv4RoutingDecision} control info.
The control info contains the IP address of the next hop, and the
identifier of the interface it should be sent. The ARP module translate
the IP address to the hardware address on the local net of the specified
interface and forwards the datagram to the interface card.

\subsection{Interface with higher layer}

Higher layer protocols should be connected to the \ttt{transportIn}/\ttt{transportOut}
gates of the \nedtype{IPv4} module.

\subsubsection*{Sending packets}

Higher layer protocols can send a packet by attaching a \cppclass{IPv4ControlInfo}
object to their packet and sending it to the \nedtype{IPv4} module.

% receiving IP datagrams from higher layer?

The following fields must be set in the control info:
\begin{itemize}
  \item \fvar{procotol}: the \ttt{Protocol} field of the IP datagram. Valid values
        are defined in the \ttt{IPProtocolId} enumeration.
  \item \fvar{destAddr}: the \ttt{Destination Address} of the IP datagram.
\end{itemize}

Optionally the following fields can be set too:
\begin{itemize}
\item \fvar{scrAddr}: \ttt{Source Address} of the IP datagram. If given it must match with the
      address of one of the interfaces of the node, but the datagram is not necessarily
      routed through that interface. If left unspecified, then the address of the
      outgoing interface will be used.
\item \fvar{timeToLive}: TTL of the IP datagram or -1 (unspecified). If unspecified then the TTL
      of the datagram will be 1 for destination addresses in the
      224.0.0.0 -- 224.0.0.255 range. (Datagrams with these special multicast addresses
      do not need to go further that one hop, routers does not forward these datagrams.)
      Otherwise the TTL field is determined by the \fpar{defaultTimeToLive} or
      \fpar{defaultMCTimeToLive} module parameters depending whether the destination
      address is a multicast address or not.
\item \fvar{dontFragment}: the \ttt{Don't Fragment} flag of the outgoing datagram (default is \fkeyword{false})
\item \fvar{diffServCodePoint}: the \ttt{Type of Service} field of the outgoing datagram.
      (ToS is called \ttt{diffServCodePoint} in \msgtype{IPv4Datagram} too.)
\item \fvar{interfaceId}: id of outgoing interface (can be used to limit broadcast or restrict routing).
\item \fvar{nextHopAddr}: explicit routing info, used by Manet DSR routing. If specified, then
      \ttt{interfaceId} must also be specified. Ignored in Manet routing is disabled.
\end{itemize}

The IP module encapsulates the transport layer datagram into an \msgtype{IPv4Datagram}
and fills in the header fields according to the control info. The \ttt{Identification}
field is generated by incrementing a counter.

The generated IP datagram is passed to the routing algorithm. The routing decides if the
datagram should be delivered locally, or passed to one of the network interfaces
with a specified next hop address, or broadcasted on one or all of the network interfaces.
The details of the routing is described in the next subsection (\ref{subsec:ip_routing})
in detail.

Before sending the datagram on a specific interface, the \nedtype{IPv4} module
checks if the packet length is smaller than the \ttt{MTU} of the interface.
If not, then the datagram is fragmented. When the \ttt{Don't Fragment} flag
forbids fragmentation, an \ttt{Destination Unreachable} ICMP error is generated
with the \ttt{Fragmentation Error (5)} error code.
\begin{note}
Each fragment will encapsulate the whole higher layer datagram, although the
length of the IP datagram corresponds to the fragment length.
\end{note}

The fragments are sent to the \nedtype{ARP} module through the \ttt{queueOut} gate.
The \nedtype{ARP} module forwards the datagram immediately to point-to-point interface
cards. If the outgoing interface is a 802.x card, then before forwarding the datagram
it performs address resolution to obtain the MAC address of the destination.

% FIXME there is no fragmentation if the packet is delivered through a local interface (e.g. loopback).
%       check if this is correct. (Loopback IF has an MTU too.)

% fragmentAndSend()
% FIXME: when a fragment is fragmented, then 'Fragment Offset' is not set correctly (starts from 0, instead of the fragment's Fragment Offset)
% FIXME: 'Fragment Offset' should be measured in 8-byte offsets! Now it is handled in byte units (and serialized so) 
% FIXME: TTL<=0 should be checked in fragmentAndSend() before fragmenting. (sendDatagramToOutput only called from fragmentAndSend())

\subsubsection*{Receiving packets}

The \nedtype{IPv4} module of hosts processes the datagrams received from the network
in three steps:
\begin{enumerate}
  \item Reassemble fragments
  \item Decapsulate the transport layer datagram
  \item Dispatch the datagram to the appropriate transport protocol
\end{enumerate}

When a fragment received, it is added to the fragment buffer of the IP.
If the fragment was the last fragment of a datagram, the processing of 
the datagram continues with step 2. The fragment buffer stores the reception
time of each fragment. Fragments older than \fpar{fragmentTimeout} are
purged from the buffer. The default value of the timeout is 60s. The
timeout is only checked when a fragment is received, and at least 10s
elapsed since the last check.

An \msgtype{IPv4ControlInfo} attached to the decapsulated transport layer packet.
The control info contains fields copied from the IP header (source and destination
address, protocol, TTL, ToS) as well as the interface id through it was received.
The control info also stores the original IP datagram, because the transport
layer might signal an ICMP error, and the ICMP packet must encapsulate the
erronous IP datagram.
\begin{note}
IP datagrams containing a DSR packet are not decapsulated, the unchanged IP
datagram is passed to the DSR module instead.
\end{note}

After decapsulation, the transport layer packet will be passed to the appropriate
transport protocol. It must be connected to one of the \ttt{transportOut[]} gate.
The \nedtype{IPv4} module finds the gate using the \ttt{protocol id}$\rightarrow$
\ttt{gate index} mapping given in the \fpar{protocolMapping} string parameter.
The value must be a comma separated list of ''<protocol\_id>:<gate\_index>'' items.
For example the following line in the ini file maps TCP (6) to gate 0, UDP (17)
to gate 1, ICMP (1) to gate 2, IGMP (2) to gate 3, and RVSP (46) to gate 4.
\begin{inifile}
**.ip.protocolMapping="6:0,17:1,1:2,2:3,46:4"
\end{inifile}
If the protocol of the received IP datagram is not mapped, or the gate
is not connected, the datagram will be silently dropped.
% FIXME should send DESTINATION_UNREACHABLE/PROTOCOL_UNREACHABLE
% FIXME reassembleAndDeliver() checks that transport gate is connected, but handleReceivedICMP() does not check it

Some protocols are handled differently:
\begin{itemize}
  \item \ttt{ICMP}: ICMP errors are delivered to the protocol
        whose packet triggered the error. Only ICMP query
        requests and responses are sent to the \nedtype{ICMP} module.
  \item \ttt{IP}: sent through \ttt{preRoutingOut} gate. (bug!)
  \item \ttt{DSR}: ??? (subsection about Manet routing?)
\end{itemize}

% FIXME reassembleAndDeliver(): packets with IP protocol are sent through 'preRoutingOut' gate,
%       but there is no such gate in the IPv4 module. 


\subsection{Routing, and interfacing with lower layers}
\label{subsec:ip_routing}

The output of the network interfaces are connected to the
\ttt{queueIn} gates of the \nedtype{IPv4} module. The incoming
packets are either IP datagrams or ARP responses. The IP datagrams
are processed by the \nedtype{IPv4} module, the ARP
responses are forwarded to the \nedtype{ARP}. 

The \nedtype{IPv4} module first checks the error bit of the
incoming IP datagrams. There is a $header length/packet length$
probability that the IP header contains the error (assuming
1~bit error). With this probability an ICMP \ttt{Parameter Problem}
generated, and the datagram is dropped.

% FIXME if IP datagram hasBitError(), but it is decided not be in the IP header,
%       then the decapsulated packet should have the bit error.

When the datagram does not contain error in the IP header,
its \ttt{Time to Live} field is decremented and a routing decision
is made. As a result of the routing the datagram is either
delivered locally, or sent out one or more output interface.
When it is sent out, the routing algorithm must compute the
next hop of its route. The details are differ, depending on
that the destination address is multicast address or not.

When the datagram is decided to be sent up, it is processed
as described in the previous subsection (Receiving packets).
If it is decided to be sent out through some interface, it
is actually sent to the \nedtype{ARP} module through the
\ttt{queueOut} gate. An \msgtype{IPv4RoutingDecision} control
info is attached to the outgoing packet, containing the
outgoing interface id, and the IP address of the next hop.
The \nedtype{ARP} module resolve the IP address to a hardware
address if needed, and forwards the datagram to next hop.

\subsubsection*{Unicast/broadcast routing}

Datagrams having unicast or broadcast destination addresses are
routed in the following steps:

\begin{enumerate}
  \item Process source routing options.
  \item Deliver datagram locally. If the destination address is a local
  address, the limited broadcast address (255.255.255.255), or a local
  broadcast address, then it will be sent to the transport layer.
  \item Drop packets received from the network when IP forwarding is disabled.
  \item Route datagrams received from higher layer or network. There are
  three cases:
  \begin{enumerate}
    \item The datagram comes from the transport layer and its destination is
    the limited or a local broadcast address.
    In this case the datagram is sent through the specified
    broadcast interface. If the transport layer did not specify
    the interface, then a copy of the datagram is sent through each interface
    (except loopbacks).
    (The \fpar{forceBroadcast} parameter must be \fkeyword{true} to enable this.) 
    The next hop address will be 255.255.255.255, which is mapped to a link layer
    broadcast address if the interface supports it. 
    \item The datagram comes from the transport layer and the
    transport protocol provided explicit routing (Manet routing).
    If Manet routing is enabled, then the datagram will be sent
    through the specified interface to the specified next hop.
    If Manet routing is disabled or the next hop is not specified
    (only the outgoing interface), then the datagram is sent through
    that interface. If the specified interface is a broadcast interface,
    then the next hop is computed by looking up the best route
    from the routing table.
    \item The datagram received from the network, or it comes from
    the transport layer, but the outgoing interface is not specified.
    In this case, the best route to the destination is looked up from the
    routing table. The datagram forwarded to gateway of the
    route or directly to the destination. If no route is found, then
    a \ttt{Destination Unreachable} ICMP error is sent to the source of the
    datagram.
  \end{enumerate}
\end{enumerate}

% FIXME forceBroadcast branch is never reached (bug #366)
% FIXME in forceBroadcast branch dataAux sould be passed to fragmentAndSend
% FIXME local broadcasts from HL does not looped back, it is necessary because network cards do not receive the messages they send
% FIXME when a broadcast message is locally delivered and its source address is unspecified,
%       the destination address is copied to the source, before sending it up.
%       But broadcast addresses are not allowed as source. (copy-paste bug?)

\subsubsection*{Multicast routing}

If the destination address of the datagram is a multicast address (category D address),
then it is routed specially. The differences from normal routing rules are:
\begin{itemize}
  \item It can be delivered locally if the destination address
  is in the multicast group of some interface.
  \item The datagram is forwarded to each \emph{multicast route}
  found in the routing table.
\end{itemize}

More specifically, the routing routine for multicast datagrams performs these steps:
\begin{enumerate}
  \item Discard packets that arrived at an interface that does not belong
  to the best route to the source of the packet (i.e. did not arrived on the 
  shortest path).
  \item Discard incoming packets that can not be delivered locally and
  can not be forwarded.
  A non-local packet can not be forwarded if IP forwarding is disabled or the
  destination is a link local multicast address (224.0.0.x).
  \item Deliver the datagram locally. If the destination address of the
  datagram belongs to a multicast group of any local interface, it is sent
  up to the transport layer.
  \item Forward the multicast datagram. If the packet comes from the
  higher layer and its outgoing interface specified, then it is sent out
  on the specified interface only (with next hop address = destitation address).
  Otherwise a copy of the datagram is sent on each interface described by
  multicast routes to the destination. In this case the next hop address will be
  the gateway address of the route. If the original datagram is received
  from the network, then it is not sent on the interface it arrived at.
\end{enumerate}
        

\subsection{Parameters}

\begin{itemize}
  \item \fpar{procDelay}
  \item \fpar{timeToLive}
  \item \fpar{multicastTimeToLive}
  \item \fpar{protocolMapping}
  \item \fpar{fragmentTimeout}
  \item \fpar{forceBroadcast}
\end{itemize}

compile time options: WITH\_MANET, NEWFRAGMENT

\subsection{Statistics}

The \nedtype{IPv4} module does not write any statistics into files,
but it has some statistical information that can be watched during
the simulation in the gui environment.
\begin{itemize}
  \item \ttt{numForwarded}: number of forwarded datagrams, i.e. sent to one of the
        interfaces (not broadcast), counted before fragmentation.
  \item \ttt{numLocalDeliver}: number of datagrams locally delivered.
        (Each fragment counted separately.)
  \item \ttt{numMulticast}: number of routed multicast datagrams.
  \item \ttt{numDropped} number of dropped packets.
        Either because there is no any interface, the interface is not specified and
        no \fpar{forceBroadcast}, or received from the network but IP forwarding disabled.
  \item \ttt{numUnroutable}: number of unroutable datagrams, i.e. there is no
        route to the destination. (But if outgoing interface is specified it is routed!)
\end{itemize}

In the graphical interface the bubble of the \nedtype{IPv4} module
also displays these counters.


\section{The RoutingTable module}

The \nedtype{RoutingTable} module represents the routing table.
This object has one instance per host or router. It has methods to manage
the route table and the interface table,
so one can achieve functionality similar to the \fprog{route} and
\fprog{ifconfig} commands.

This is a simple module without gates, it requires function calls to it
(message handling does nothing). Methods are provided for reading and
updating the interface table and the route table, as well as for unicast
and multicast routing.

Interfaces are dynamically registered: at the start of the simulation,
every L2 module adds its own interface entry to the table.

The route table is read from a file; the file can
also fill in or overwrite interface settings. The route table can also
be read and modified during simulation, typically by routing protocol
implementations (e.g. OSPF).

Entries in the route table are represented by \cppclass{IPv4Route} objects.
\cppclass{IPv4Route} objects can be polymorphic: if a routing protocol needs
to store additional data, it can simply subclass from \cppclass{IPv4Route},
and add the derived object to the table. The \cppclass{IPv4Route} object
has the following fields:
\begin{itemize}
  \item \ttt{host} is the IP address of the target of the route (can be a host or network).
                   When an entry searched for a given destination address, the destination
                   address is compared with this \ttt{host} address using the \ttt{netmask}
                   below, and the longest match wins.
  \item \ttt{netmask} used when comparing \ttt{host} with the detination address.
                     It is 0.0.0.0 for the default route, 255.255.255.255 for
                     host routes (exact match), or the network or subnet mask
                     for network routes.
  \item \ttt{gateway} is the IP address of the gateway for indirect routes, or
                      0.0.0.0 for direct routes. Note that 0.0.0.0 can be used
                      even if the destination is not directly connected to this
                      node, but can be found using proxy ARP. 
  \item \ttt{interface} the outgoing interface to be used with this route.
  \item \ttt{type} \ttt{DIRECT} or \ttt{REMOTE}. For direct routes, the next hop
                   address is the destination address, for remote routes it is
                   the gateway address.
  \item \ttt{source} \ttt{MANUAL}, \ttt{IFACENETMASK}, \ttt{RIP}, \ttt{OSPF},
        \ttt{BGP}, \ttt{ZEBRA}, \ttt{MANET}, or \ttt{MANET2}. \ttt{MANUAL} means
        that the route was added by a routing file, or a network configurator.
        \ttt{IFACENETMASK} routes are added for each interface of the node.
        Other values means that the route is managed by the specific routing
        daemon.
  \item \ttt{metric} the ``cost'' of the route. Currently not used when choosing
                     the best route.
\end{itemize}

The \nedtype{RoutingTable} module has the following parameters:

\begin{itemize}
  \item \fpar{routerId}: for routers, the router id using IPv4 address dotted notation;
        specify ``auto'' to select the highest interface address; should be left empty ``''
        for hosts
  \item \fpar{IPForward}: turns IP forwarding on/off (It is always \fkeyword{true}
                          in a \nedtype{Router} and is \fkeyword{false} by default
                          in a \nedtype{StandardHost}.)
  \item \fpar{routingFile}: routing table file name
\end{itemize}

% FIXME RoutingTable::invalidateCache() should clear localBroadcastAddresses.
% RoutingTable::findBestMatchingRoute() should search in this order:
%          1. host routes (exact match)
%          2. network routes (longest match)
%          3. default routes (round robin)
%   It is ok, if host routes has 255.255.255.255 netmask, and default has 0.0.0.0 netmask.
% FIXME RoutingTable::findBestMatchingRoute() if(...MANET...) branch always set bestRoute to NULL,
%       because if there were exact match, it would have been choosen in the previous loop.

\subsection{The IP routing files}

Routing files are files with \ttt{.irt} or \ttt{.mrt} extension,
and their names are passed in the routingFileName parameter
to RoutingTable modules. RoutingTables are present in all
IP nodes (hosts and routers).

Routing files may contain network interface configuration and static
routes. Both are optional. Network interface entries in the file
configure existing interfaces; static routes are added to the route table.

Interfaces themselves are represented in the simulation by modules
(such as the PPP module). Modules automatically register themselves
with appropriate defaults in the RoutingTable, and entries in the
routing file refine (overwrite) these settings.
Interfaces are identified by names (e.g. ppp0, ppp1, eth0) which
are normally derived from the module's name: a module called
\ttt{"ppp[2]"} in the NED file registers itself as interface ppp2.

An example routing file (copied here from one of the example simulations):

\begin{verbatim}
ifconfig:

# ethernet card 0 to router
name: eth0   inet_addr: 172.0.0.3   MTU: 1500   Metric: 1  BROADCAST MULTICAST
Groups: 225.0.0.1:225.0.1.2:225.0.2.1

# Point to Point link 1 to Host 1
name: ppp0   inet_addr: 172.0.0.4   MTU: 576   Metric: 1

ifconfigend.

route:
172.0.0.2   *           255.255.255.255  H  0   ppp0
172.0.0.4   *           255.255.255.255  H  0   ppp0
default:    10.0.0.13   0.0.0.0          G  0   eth0

225.0.0.1   *           255.255.255.255  H  0   ppp0
225.0.1.2   *           255.255.255.255  H  0   ppp0
225.0.2.1   *           255.255.255.255  H  0   ppp0

225.0.0.0   10.0.0.13   255.0.0.0        G  0   eth0

routeend.
\end{verbatim}

The \ttt{ifconfig...ifconfigend.} part configures interfaces,
and \ttt{route..routeend.} part contains static routes.
The format of these sections roughly corresponds to the output
of the \ttt{ifconfig} and \ttt{netstat -rn} Unix commands.

An interface entry begins with a \ttt{name:} field, and lasts until
the next \ttt{name:} (or until \ttt{ifconfigend.}). It may
be broken into several lines.

Accepted interface fields are:

\begin{itemize}
  \item \ttt{name:} - arbitrary interface name (e.g. eth0, ppp0)
  \item \ttt{inet\_addr:} - IP address
  \item \ttt{Mask:} - netmask
  \item \ttt{Groups:} Multicast groups. 224.0.0.1 is added automatically,
     and 224.0.0.2 also if the node is a router (IPForward==true).
  \item \ttt{MTU:} - MTU on the link (e.g. Ethernet: 1500)
  \item \ttt{Metric:} - integer route metric
  \item flags: \ttt{BROADCAST}, \ttt{MULTICAST}, \ttt{POINTTOPOINT}
\end{itemize}

The following fields are parsed but ignored: \ttt{Bcast},\ttt{encap},
\ttt{HWaddr}.

Interface modules set a good default for MTU, Metric (as $2*10^9$/bitrate) and
flags, but leave \fvar{inet\_addr} and \fvar{Mask} empty. \fvar{inet\_addr} and
\fvar{mask} should be set either from the routing file or by a dynamic network
configuration module.

The route fields are:

\begin{verbatim}
Destination  Gateway  Netmask  Flags  Metric Interface
\end{verbatim}

\fvar{Destination}, \fvar{Gateway} and \fvar{Netmask} have the usual meaning.
The \fvar{Destination} field should either be an IP address or ``default''
(to designate the default route). For \fvar{Gateway}, \ttt{*} is also
accepted with the meaning \ttt{0.0.0.0}.

\fvar{Flags} denotes route type:

\begin{itemize}
  \item \textit{H} ``host'': direct route (directly attached to the router), and
  \item \textit{G} ``gateway'': remote route (reached through another router)
\end{itemize}

\fvar{Interface} is the interface name, e.g. \ttt{eth0}.

% FIXME 'H' and 'G' flags should be independent. Now they excludes each other, the parser sets route.type to the last one.
%       H = host/network
%       G = indirect/direct

\subsection{Network configurators}

Configuring a large network with routing files can be a tedious task.
INET contains a module (called \nedtype{FlatNetworkConfigurator})
for automatically assigning IP addresses and filling the routing tables
of the IP nodes of a network. Add this module to the top level
of the network, and it will do the work when initialized. Do not
specify any routing file, or leave them empty, because they can
interfere with the configurator.

The \nedtype{FlatNetworkConfigurator} searches each IP nodes of the network.
(IP nodes are those modules that have the @node NED property and
has a \nedtype{RoutingTable} submodule named ``routingTable'').
The configurator then assigns IP addresses to the IP nodes, controlled
by the following module parameters:
\begin{itemize}
  \item \fpar{netmask} common netmask of the addresses (default is 255.255.0.0)
  \item \fpar{networkAddress} higher bits are the network part of the addresses,
        lower bits should be 0. (default is 192.168.0.0)
\end{itemize}

With the default parameters the assigned addresses are in the range
192.168.0.1 - 192.168.255.254, so there can be maximum 65534 nodes in the
network. The netmask of the assigned IP addresses will be 255.255.255.255,
therefore each node is a subnet in itself; there are no subnet directed
broadcast addresses. The same IP address will be assigned to each interface
of the node, except the loopback interface which always has address 127.0.0.1
(with 255.0.0.0 mask).

After assigning the IP addresses, the configurator fills in the routing tables.
There are two kind of routes:
\begin{itemize}
  \item default routes: for nodes that has only one non-loopback interface
        a route is added that matches with any destination address
        (the entry has 0.0.0.0 \ttt{host} and \ttt{netmask} fields).
        These are remote routes, but the gateway address is left unspecified.
        The delivery of the datagrams rely on the proxy ARP feature of the
        routers. 
  \item direct routes following the shortest paths: for nodes that has more
        than one non-loopback interface a separate route is added to each
        IP node of the network. The outgoing interface is chosen by the
        shortest path to the target node. These routes are
        added as direct routes, even if there is no direct link with the
        destination. In this case proxy ARP is needed to deliver the datagrams.
\end{itemize}

% FIXME shortest path calculation should exclude the nodes where IPForward is disabled.
%       If the shortest path leads to a multihomed node in which IPForward is false, each datagram will be dropped.

% FIXME weird FlatNetworkConfigurator behaviour.
%       Assigned IP addresses does not mirror the hierachy of networks (e.g. each node in an Ethernet LAN handled as a one-element subnet).
%       No gateway address is set in the routes, delivery relies on proxy ARPing.
%       Direct routes created to each node, even if there is no direct link to it.
%       Different interfaces of a node should have different IP address.
%       Broadcast capable interfaces should have a real netmast (not 255.255.255.255) to support subnet directed IP broadcasts.

\section{The ICMP module}

The Internet Control Message Protocol (ICMP) is the error reporting and
diagnostic mechanism of the Internet.
It uses the services of IP, so it is a transport layer protocol, but unlike
TCP or UDP it is not used to transfer user data. It can not be separated
from the IP, because the routing errors are reported by ICMP.

The \nedtype{ICMP} module can be used to send error messages and ping
request. It can also respond to incoming ICMP messages.

Each ICMP message is encapsulated within an IP datagram, so its delivery
is unreliable.

\begin{center}
\begin{bytefield}{32}
\bitheader{0,7,8,15,31} \\
\bitbox{8}{Type} &
\bitbox{8}{Code} &
\bitbox{16}{Checksum} \\
\bitbox{32}{Rest of header} \\
\wordbox{2}{Internet Header + 8 bytes of Original Datagram}
\end{bytefield}
\end{center}

The corresponding message class (\msgtype{ICMPMessage}) contains only
the Type and Code fields. The message encapsulates the IP packet that 
triggered the error, or the data of the ping request/reply.

% FIXME type=PARAMETER_PROBLEM, code=0: missing Pointer field from ICMPMessage
%            REDIRECT: Gateway Internet Address
%            ECHO_REQUEST, ECHO_REPLY: Identifier, Sequence Number
%            TIMESTAMP_REQUEST, TIMESTAMP_REPLY: Identifier, Sequence Number, Originate Timestamp, Receive Timestamp, Transmit Timestamp

% FIXME wrong type codes for ICMP_DESTINATION_UNREACHABLE (3), ICMP_ECHO_REQUEST (8), ICMP_ECHO_REPLY (0), ICMP_TIMESTAMP_REQUEST (13), ICMP_TIMESTAMP_REPLY (14)

% FIXME ICMP error should not be send if the original datagram
%         1. is an ICMP error
%         2. was sent to a broadcast or multicast address
%         3. datagram was sent with a link-layer broadcast
%         4. a fragment other than the first
%         5. a datagram whose source address is 0.0.0.0, 127.*.*.*, broadcast or multicast address
%      currently only the 1. and half of 2. checked

The \nedtype{ICMP} module has two methods which can be used by other modules
to send ICMP error messages:
\begin{itemize}
  \item \ffunc[sendErrorMessage]{sendErrorMessage(IPv4Datagram*, ICMPType, ICMPCode)}
        used by the network layer to report erronous IPv4 datagrams. The ICMP header
        fields are set to the given type and code, and the ICMP message will encapsulate
        the given datagram.
  \item \ffunc[sendErrorMessage]{sendErrorMessage(cPacket*, IPv4ControlInfo*, ICMPType, ICMPCode)}
        used by the transport layer components to report erronous packets. The transport
        packet will be encapsulated into an IP datagram before wrapping it into the ICMP message.
\end{itemize}

The \nedtype{ICMP} module can be accessed from other modules of the node by calling
\ffunc{ICMPAccess::get()}.

When an incoming ICMP error message is received, the \nedtype{ICMP} module
sends it out on the \ttt{errorOut} gate unchanged. It is assumed that an
external module is connected to \ttt{errOut} that can process the error
packet. There is a simple module (\nedtype{ErrorHandling}) that simply
logs the error and drops the message. Note that the \nedtype{IPv4} module
does not send REDIRECT, DESTINATION\_UNREACHABLE,
TIME\_EXCEEDED and PARAMETER\_PROBLEM messages to the \nedtype{ICMP} module,
it will send them to the transport layer module that sent the bogus
packet encapsulated in the ICMP message.
\begin{note}
ICMP protocol encapsulates only the IP header + 8 byte following the IP header
from the bogus IP packet. The ICMP packet length computed from this truncated
packet, despite it encapsulates the whole IP message object.
As a consequence, calling \ffunc{decapsulate()} on the ICMP message
will cause an ``packet length became negative'' error. To avoid this,
use \ffunc{getEncapsulatedMsg()} to access the IP packet that caused the ICMP
error. 
\end{note}

The \nedtype{ICMP} module receives ping commands on the \ttt{pingIn}
gate from the application. The ping command can be any packet
having an \cppclass{IPv4ControlInfo} control info. The packet
will be encapsulated with an \msgtype{ICMPMessage} and
handed over to the IP.

If \nedtype{ICMP} receives an echo request from IP, the original
message object will be returned as the echo reply. Of course,
before sending back the object to IP, the source and destination
addresses are swapped and the message type changed to ICMP\_ECHO\_REPLY.

When an ICMP echo reply received, the application message decapsulated
from it and passed to the application through the \ttt{pingOut} gate.
The \cppclass{IPv4ControlInfo} also copied from the \msgtype{ICMPMessage}
to the application message. 

% FIXME ICMP TIMESTAMP requests are processed as ECHO requests

% \section{The IGMP module}

\section{The ARP module}

The \nedtype{ARP} module implements the Address Resolution Protocol (RFC826).
The ARP protocol is designed to translate a local protocol address
to a hardware address. Altough the ARP protocol can be used with
several network protocol and hardware addressing schemes, in practice
they are almost always IPv4 and 802.3 addresses. The INET implementation
of the ARP protocol (the \nedtype{ARP} module) supports only
IP address $\rightarrow$ MAC address translation. 

If a node wants to send an IP packet to a node whose MAC address is unknown,
it broadcasts an ARP frame on the Ethernet network.
In the request its publish its own IP and
MAC addresses, so each node in the local subnet can update their mapping.
The node whose MAC address was requested will respond with an ARP frame
containing its own MAC address directly to the node that sent the
request. When the original node receives the ARP response, it updates 
its ARP cache and sends the delayed IP packet using the learned MAC address.

The frame format of the ARP request and reponse is shown in Figure \ref{fig:ARP_frame}.
In our case the HTYPE (hardware type), PTYPE (protocol type), HLEN (hardware address length)
and PLEN (protocol address length) are constants: HTYPE=Ethernet (1), PTYPE=IPv4 (2048), HLEN=6,
PLEN=4. The OPER (operation) field is 1 for an ARP request and 2 for an ARP response.
The SHA field contains the 48-bit hardware address of the sender, SPA field is
the 32-bit IP address of the sender; THA and TPA are the addresses of the target.
The message class corresponding to the ARP frame is \msgtype{ARPPacket}.
In this class only the OPER, SHA, SPA, THA and TPA fields are stored.
The length of an \msgtype{ARPPacket} is 28 bytes.

\begin{figure}[h]
\begin{center}
\label{fig:ARP_frame}
\begin{bytefield}{16}
\bitheader{0,7,8,15} \\
\bitbox{16}{HTYPE} \\
\bitbox{16}{PTYPE} \\
\bitbox{8}{HLEN} &
\bitbox{8}{PLEN} \\
\bitbox{16}{OPER} \\
\wordbox{3}{SHA} \\
\wordbox{2}{SPA} \\
\wordbox{3}{THA} \\
\wordbox{2}{TPA} \\
\end{bytefield}
\caption{ARP frame}
\end{center}
\end{figure}

The \nedtype{ARP} module receives IP datagrams and ARP responses from \nedtype{IPv4}
on the \ttt{ipIn} gate and transmits IP datagrams and ARP requests on the \ttt{nicOut[]} gates
towards the network interface cards. ARP broadcasts the requests on the local network,
so the NIC's entry in the \nedtype{InterfaceTable} should have \ffunc{isBroadcast()} flag
set in order to participate in the address resolution.

The incoming IP packet should have an attached \cppclass{IPv4RoutingDecision} control
info containing the IP address of the next hop. If the hardware address is found
in the ARP cache, then the packet is transmitted to the addressed interface immediately.
Otherwise the packet is queued and an address resolution takes place.
The \nedtype{ARP} module creates an \msgtype{ARPPacket} object, sets the sender
MAC and IP address to its own address, sets the destination IP address
to the address of the target of the IP datagram, leave the destination MAC address
blank and broadcasts the packet on each network interface with broadcast capability.
Before sending the ARP packet, it retransmission a timer. If the timer expires,
it will retransmit the ARP request, until the maximum retry count is reached.
If there is no response to the ARP request, then the address resolution fails,
and the IP packet is dropped from the queue. Otherwise the MAC address of the
destination is learned and the IP packet can be transmitted on the corresponding
interface.

When an ARP packet is received on the \ttt{ipIn} gate, and the sender's IP
is already in the ARP cache, it is updated with the information in the ARP frame.
Then it is checked that the destination IP of the packet matches with our
address. In this case a new entry is created with the sender addresses in the
ARP cache, and if the packet is a request a response is created and sent directly
to the originator. If proxy ARP is enabled, the request can be responded
with our MAC address if we can route IP packets to the destination.

Usually each \nedtype{ARP} module maintains a local ARP cache.
However it is possible to use a global cache. The global cache is filled
in with entries of the IP and MAC addresses of the known interfaces
when the ARP modules are initiated (at simulation time 0).
\nedtype{ARP} modules that are using the global ARP cache
never initiate an address resolution; if an IP address not
found in the global cache, the simulation stops with an error.
However they will respond to ARP request, so the simulation can
be configured so that some \nedtype{ARP}s use local, while others
the global cache.

When an entry is inserted or updated in the local ARP cache,
the simulation time saved in the entry. The mapping in the
entry is not used after the configured \fpar{cacheTimeout}
elapsed. This parameter does not affect the entries of
the global cache however.

% FIXME why the global cache is cleared when an ARP module is deleted?

The module parameters of \nedtype{ARP} are:

\begin{itemize}
  \item \fpar{retryTimeout}: number of seconds ARP waits between retries to resolve an IPv4 address (default is 1s)
  \item \fpar{retryCount}: number of times ARP will attempt to resolve an IPv4 address (default is 3)
  \item \fpar{cacheTimeout}: number of seconds unused entries in the cache will time out (default is 120s)
  \item \fpar{proxyARP}: enables proxy ARP mode (default is \fkeyword{true})
  \item \fpar{globalARP}: use global ARP cache (default is \fkeyword{false})
\end{itemize}

The \nedtype{ARP} module emits four signals:

\begin{itemize}
  \item \ttt{sentReq}: emits 1 each time an ARP request is sent
  \item \ttt{sentReplies}: emits 1 each time an ARP response is sent
  \item \ttt{initiatedResolution}: emits 1 each time an ARP resolution is initiated 
  \item \ttt{failedResolution}: emits 1 each time an ARP resolution is failed
\end{itemize}

These signals are recorded as vectors and their counts as scalars.

% TODO watches, animation effects

\section{The IGMP module}


\section{The NetworkLayer module}

The \nedtype{NetworkLayer} module packs the \nedtype{IP}, \nedtype{ICMP},
\nedtype{ARP}, and \nedtype{IGMP} modules into one compound module.
The compound module defines gates for connecting UDP, TCP, SCTP, RSVP and
OSPF transport protocols. The \ttt{pingIn} and \ttt{pingOut} gates of the
\nedtype{ICMP} module are also available, while its \ttt{errorOut} gate
is connected to an inner \nedtype{ErrorHandling} component that writes
the ICMP errors to the log.

The component can be used in hosts and routers to support IPv4.

\section{The NetworkInfo module}

The \nedtype{NetworkInfo} module can be used to dump detailed information
about the network layer. This module does not send or received messages,
it is invoked by the \nedtype{ScenarioManager} instead. For example
the following \nedtype{ScenarioManager} script dump the routing table
of the \ttt{LSR2} module at simulation time $t=2$ into \ffilename{LSR2\_002.txt}:
\begin{filelisting}
<scenario>
  <at t="2">
    <routing module="NetworkInfo" target="LSR2" file="LSR2_002.txt"/>
  </at>
</scenario>
\end{filelisting}

The module currently support only the \ttt{routing} command which dumps
the routing table. The command has four parameters given as XML attributes:
\begin{itemize}
  \item \ttt{target} the name of the node that owns the routing table to be dumped
  \item \ttt{filename} the name of the file the output is directed to
  \item \ttt{mode} if set to ``a'', the output is appended to the file,
                   otherwise the target is truncated if the file existed
  \item \ttt{compat} if set to ``linux'', then the output is generated
                     in the format of the \ttt{route -n} command of Linux.
                     The output is sorted only if \ttt{compat} is
                     \fkeyword{true}.
\end{itemize}

\section{Applications}

The applications described in this section uses the services of the network
layer only, they do not need transport layer protocols.
They can be used with both IPv4 and IPv6.

\subsection{IP traffic generators}

Traffic generators that connect directly to IP (without using TCP or UDP):
\nedtype{IIPvXTraffixGenerator} (prototype).
 \nedtype{IPvXTrafGen},

Sends IP or IPv6 datagrams to the given address at the given \fpar{sendInterval}.
The \fpar{sendInterval} parameter can be a constant or a random value (e.g. exponential(1)).
If the \fpar{destAddresses} parameter contains more than one address, one
of them is randomly for each packet. An address may be given in the
dotted decimal notation (or, for IPv6, in the usual notation with colons),
or with the module name. (The \cppclass{IPvXAddressResolver} class is used to resolve
the address.) To disable the model, set destAddresses to "".

The \nedtype{IPvXTrafGen} sends messages with length \fpar{packetLength}.
The sent packet is emitted in the \fsignal{sentPk} signal.
The length of the sent packets can be recorded as scalars and vectors.

% FIXME packetLength declared as volatile, but in fact it is not.

The \nedtype{IPvXTrafSink} can be used as a receiver of the packets
generated by the traffic generator. This module emits the packet
in the \fsignal{rcvdPacket} signal and drops it. The \ttt{rcvdPkBytes}
and \ttt{endToEndDelay} statistics are generated from this signal.

The \nedtype{IPvXTrafGen} can also be the peer of the traffic generators;
it handles the received packets exactly like \nedtype{IPvXTrafSink}.

You can see an example usage of these applications in \ffilename{examples/inet/routerperf/omnetpp.ini}
simulaton.

\subsection{The PingApp application}

The \nedtype{PingApp} application
generates ping requests and calculates the packet loss and round trip
parameters of the replies.

Start/stop time, sendInterval etc. can be specified via parameters. An address
may be given in the dotted decimal notation (or, for IPv6, in the usual
notation with colons), or with the module name.
(The \cppclass{IPvXAddressResolver} class is used to resolve the address.)
To disable send, specify empty destAddr.

Every ping request is sent out with a sequence number, and replies are
expected to arrive in the same order. Whenever there's a jump in the
in the received ping responses' sequence number (e.g. 1, 2, 3, 5), then
the missing pings (number 4 in this example) is counted as lost.
Then if it still arrives later (that is, a reply with a sequence number
smaller than the largest one received so far) it will be counted as
out-of-sequence arrival. So the number of really lost pings will be
"lost" minus "out-of-order" (assuming there's no duplicate or bogus reply).

Uses \msgtype{PingPayload} as payload for the ICMP(v6) Echo Request/Reply packets.

\subsubsection*{Parameters}

\begin{itemize}
  \item \fpar{destAddr}: destination address
  \item \fpar{srcAddr}: source address (useful with multi-homing)
  \item \fpar{packetSize}: of ping payload, in bytes (default is 56)
  \item \fpar{sendInterval}: time to wait between pings (can be random, default is 1s)
  \item \fpar{hopLimit}: TTL or hopLimit for IP packets (default is 32)
  \item \fpar{count}: stop after \fpar{count} ping request, 0 means continuously
  \item \fpar{startTime}: send first ping request at \fpar{startTime}
  \item \fpar{stopTime}: time of finish sending, 0 means forever
  \item \fpar{printPing}: dump on stdout (default is \fkeyword{true})
\end{itemize}

\subsubsection*{Signals and Statistics}

\begin{itemize}
  \item \fsignal{endToEndDelay} value of the round trip time
  \item \fsignal{drop} number of dropped packets
  \item \fsignal{outOfOrderArrival} number of packets arrived out-of-order
  \item \fsignal{pingTx} sequence number of the sent ping request
  \item \fsignal{pingRx} sequence number of the received ping response
\end{itemize}

\ttt{pingRTT} stat

% FIXME seqNo should be part of ICMPMessage

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "usman"
%%% End:

